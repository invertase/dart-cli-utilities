// ignore_for_file: avoid_print

/*
 * Copyright (c) 2020-present Invertase Limited & Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this library except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import 'dart:convert';
import 'dart:io';

import 'package:http/http.dart' as http;

Future<List<Map<String, Object?>>> getSharedVendorsJson() async {
  final response = await http.get(
    Uri.parse(
      'https://github.com/watson/ci-info/blob/master/vendors.json?raw=true',
    ),
  );

  return List.from(jsonDecode(response.body) as List);
}

Future<List<Map<String, Object?>>> getLocalVendorsJson() async {
  final jsonString = await File('tools/vendors.json').readAsString();
  return List.from(jsonDecode(jsonString) as List);
}

Future<List<Map<String, Object?>>> getAllVendors() async {
  final sharedVendors = await getSharedVendorsJson();
  final localVendors = await getLocalVendorsJson();
  final allVendors = List<Map<String, Object?>>.from(sharedVendors);
  allVendors.retainWhere(
    (sharedVendor) =>
        localVendors.indexWhere(
          (localVendor) => localVendor['name'] == sharedVendor['name'],
        ) ==
        -1,
  );
  allVendors.addAll(localVendors);
  allVendors
      .sort((a, b) => (a['name']! as String).compareTo(b['name']! as String));
  return allVendors;
}

void _writeGeneratedHead(StringBuffer buffer) {
  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// GENERATED BY CI PACKAGE');
  buffer.writeln('// ignore_for_file: type=lint');
  buffer.writeln("import 'dart:io';");
}

void _writeGeneratedVendorStaticGetter(
  StringBuffer buffer,
  Map<String, Object?> vendor,
) {
  buffer.writeln(
    '  /// Returns true if ${vendor['name']} is the current CI vendor.',
  );
  buffer.writeln('  static bool get IS_${vendor['constant']} {');
  buffer.write('    return ');
  final env = vendor['env'];
  if (env is String) {
    buffer.write("Platform.environment.containsKey('$env')");
  } else if (env is Map) {
    final entries = <String>[];
    for (final entry in env.entries) {
      entries.add(
        "Platform.environment['${entry.key}'] == '${entry.value}'",
      );
    }
    buffer.write(entries.join(' && '));
  } else if (env is List) {
    buffer.write(
      env
          .map<String>((dynamic e) => 'Platform.environment.containsKey("$e")')
          .join(' && '),
    );
  }

  buffer.writeln(';');
  buffer.writeln('  }');
  buffer.writeln();
}

void _writeGeneratedVendorClass(
  StringBuffer buffer,
  List<Map<String, Object?>> vendors,
) {
  buffer.writeAll(
    <String>[
      'class Vendor {',
      '  Vendor._(this.name, this.isPullRequest);',
      '',
      '  /// The name of the CI vendor.',
      '  final String name;',
      '',
      '  /// Whether this CI run is for a Pull Request.',
      '  final bool isPullRequest;',
      '',
      '',
    ],
    '\n',
  );
  for (final vendor in vendors) {
    _writeGeneratedVendorStaticGetter(buffer, vendor);
  }
  _writeGeneratedVendorClassCurrentVendorInstance(buffer, vendors);
  buffer.writeln('}');
}

void _writeGeneratedVendorClassCurrentVendorInstance(
  StringBuffer buffer,
  List<Map<String, Object?>> vendors,
) {
  buffer.writeln(
    '  /// Returns the current CI [Vendor] or [null] if no CI vendor detected (e.g. not running on CI).',
  );
  buffer.writeln('  static Vendor? get current {');
  for (final vendor in vendors) {
    buffer.writeln('    if (IS_${vendor['constant']}) {');
    buffer.write("      return Vendor._('${vendor['name']}', ");
    final pr = vendor['pr'];
    if (pr == null) {
      buffer.write('false');
    } else if (pr is String) {
      buffer.write("Platform.environment.containsKey('$pr')");
    } else if (pr is Map) {
      if (pr['any'] != null && pr['any'] is List) {
        buffer.write(
          (pr['any'] as List)
              .map<String>(
                (dynamic e) => 'Platform.environment.containsKey("$e")',
              )
              .join(' || '),
        );
      } else if (pr['env'] != null && pr['ne'] != null) {
        buffer.write("Platform.environment['${pr['env']}'] != '${pr['ne']}'");
      } else {
        buffer.write(
          (pr.entries)
              .map<String>(
                (MapEntry e) =>
                    'Platform.environment["${e.key}"] == "${e.value}"',
              )
              .join(' && '),
        );
      }
    }
    buffer.writeln(',);');
    buffer.writeln('    }');
    buffer.writeln();
  }
  buffer.writeln('    return null;');
  buffer.writeln('  }');
}

Future<void> generateVendorsDart(List<Map<String, Object?>> vendors) async {
  final file = File('lib/src/vendor.g.dart');
  final buffer = StringBuffer();
  _writeGeneratedHead(buffer);
  _writeGeneratedVendorClass(buffer, vendors);
  await file.writeAsString(buffer.toString());
  await Process.run('dart', [
    'format',
    file.path,
  ]);
}

Future<void> main() async {
  final vendors = await getAllVendors();
  await generateVendorsDart(vendors);
}
